---
title: oop_4创建与销毁
date: 2023-01-26 20:39:08
tags: c++
---
# 创建与销毁
<!-- more -->
## 程序可靠性
- OOP三性：简单性、清晰性、普遍性
- 对用户定义类型进行严格的类型检查
- 隐藏实现，防止受到不必要的干扰
- 对象的初始化和清除，需要自动进行
  - 忘记初始化或清除变量可能会导致程序崩溃。
  - 由类生成的对象是一种新型的变量，也要初始化。
  - 由于隐藏实现（访问权限控制），对象的有些私有数据成员只有类的设计者知道，而且只允许类的成员函数访问。
  - 尽管可以由通过显式调用对象成员函数来初始化对象，但这种做法缺少强制性，因而容易被程序员遗忘。
## 构造函数
- 构造函数没有返回值类型，函数名与类名相同
- 类的构造函数可以重载，即可以使用不同的函数参数进行对象初始化
```c++
class Student {
    int ID;
public:
    Student(int id) { ID = id; }
    /*
    构造函数可以使用初始化列表初始化成员数据
    Student(int id) : ID(id) { }
    */
    Student(int year, int order) { 
			ID = year * 10000 + order; 
	 }
};
```
- 在构造函数的初始化列表中，还可以调用其他构造函数，称为“委派构造函数”
```c++
class Info {
public:
    Info() { Init(); }
    Info(int i) : Info() { id = i; }
    Info(char c) : Info() { gender = c; }
private:
    void Init() { .... }// 其他初始化
    int id;		
    char gender;
    ...
};
```
### 就地初始化
- C++11之前，类中的一般成员变量不能在类定义时进行初始化，它们的初始化操作只能通过构造函数进行。
```c++
class A {
private:
	int a = 1; //声明+初始化
double b {2.0}; //声明+初始化
public:
	A() {} //a=1 b=2.0
	A(int i):a(i) {} //a=i b=2.0
	A(int i, double j):a(i), b(j) {}	 //a=i b=j
};
```
- 注意：就地初始化只是一种简便的表达方式，实际操作仍然在对象构造的时候执行。
## 析构函数
- 一个类只有一个析构函数，名称是“~类名”，没有函数返回值，没有函数参数。
- 编译器在对象生命期结束时自动调用类的析构函数，以便释放对象占用的资源，或其他后处理
```c++
class ClassRoom {
    int num;
    int* ID_list;
public:
    ClassRoom() : num(0), ID_list(nullptr) {}
    ...
    ~ClassRoom() {  // 析构函数
        if (ID_list) delete[] ID_list; // 释放内存    
    }
};
```
- 先执行类的析构函数，再调用成员变量的析构
- 隐式定义的析构函数：未定义析构函数时，编译器自动生成隐式析构函数
  - 隐式定义的析构函数不会delete指针成员
```c++
class ClassRoom {
    int num;
    int* ID_list;
};
//和下面这种写法等价
class ClassRoom {
    int num;
    int* ID_list;
public:
	~ClassRoom() {}
};
//但这种写法会造成内存泄漏，因为没有delete指针成员ID_list
```
需要在析构函数中使用delete[]来释放指针所指向的内存
```c++
class ClassRoom {
    int num;
    int* ID_list;
public:
	~ClassRoom() {
        delete[]ID_list;
    }
};
```
还有一种写法
- 使用``std::unique_ptr<int[]> ID_list``代替原来的``int* ID_list``，避免手动释放内存所带来的风险
- ``std::unique_ptr``是 C++11 标准库中的一个智能指针类型，具有自动内存管理的能力，在没有任何指针指向它所管理的内存时自动释放这块内存
- 用默认析构函数来实现析构函数，即``~ClassRoom() = default``
```c++
#include <memory>
class ClassRoom {
    int num;
    std::unique_ptr<int[]> ID_list;
public:
    ~ClassRoom() = default;
};
```
### 局部对象的构造与析构
### 全局对象的构造与析构
- 在main()函数调用之前进行初始化。
- 在同一编译单元中，按照定义顺序进行初始化。
  - 编译单元：通常同一编译单元就是同一源文件
- 不同编译单元中，对象初始化顺序不确定。
- 在main()函数执行完return之后，对象被析构。
**注意：**
- 全局对象的构造顺序不能完全确定，所以全局对象之间不能有依赖关系，否则会出现问题
- 全局对象会增大代码的耦合性，导致程序难以复用或者测试
- 使用参数来替代全局对象
## 引用
- 具名变量的别名：类型名 & 引用名 变量名
```c++
int v0; int & v1 = v0; 
//v1是变量v0的引用，它们在内存中是同一单元的两个不同名字
```
- 引用必须在定义时进行初始化，且不能修改引用指向
- 被引用变量名可以是类的成员变量，如``int & m = s.m;``
- 函数参数是引用类型，表示函数的形式参数与实际参数是同一个变量，改变形参将改变实参。
```c++
//调用以下函数将交换实参的值：
void swap(int& a, int& b)
{  int tmp = b; b = a; a = tmp; }
```
### 引用和指针的区别
- 不存在空引用。引用必须连接到一块合法的内存。
- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
- 引用必须在创建时被初始化为一个对象。指针可以在初始化时置空，之后再指向对象。


## 运算符重载
- 运算符重载需要按规则声明执行该运算的函数
  - 例如 + 对应 operator+
- 运算重载一般有两种方式（注意参数不同）
  - 全局函数的运算符重载``A operator+(A a, A b) {…}``
  - 成员函数的运算符重载
```c++
class A{
	int data;
public:
	A operator+(A b) {…};
};
```


### 可以重载的运算符
- 双目算术运算符	
  - ``+`` (加)，``-``(减)，``*``(乘)，``/``(除)，``% ``(取模)
- 关系运算符
  - ``==``(等于)，``!=`` (不等于)，``<`` (小于)，``>``(大于>，``<=``(小于等于)，``>=``(大于等于)
- 逻辑运算符
  - ``||``(逻辑或)，``&&``(逻辑与)，``!``(逻辑非)
- 单目运算符
  - ``+`` (正)，``-``(负)，``*``(指针)，``&``(取地址)
- 自增自减运算符
  - ``++``(自增)，``--``(自减)
- 位运算符
  - ``|``(按位或)，``&``(按位与)，``~``(按位取反)，``^``(按位异或)，``<<``(左移)，``>>``(右移)
- 赋值运算符
  - ``=``,``+=``,``-=``,``*=``,``/=``,``%=``,``&=``,``|=``,``^=``,``<<=``,``>>=``
- 空间申请与释放	
  - ``new``,`` delete``, ``new[]`` , ``delete[]``
- 其他运算符
  - ``()``(函数调用)，``->``(成员访问)，``,``(逗号)，``[]``(下标)

- 高级难度
  - （注意返回值是否需要引用，有什么区别？）
  - 自增运算符（前置和后置）两种 ++（自增）
    - 前缀运算符重载声明
      - ClassName operator++();
      - ClassName operator--();
    - 后缀运算符重载声明
      - ClassName operator++(int dummy);
        - ++a $\Leftrightarrow$ operator++(a)
        - a++ $\Leftrightarrow$ operator++(a,int)//哑元，后缀
      - ClassName operator--(int dummy);
    - 通过在函数体中没有使用的哑元参数dummy来区分前缀与后缀的同名重载
    - 哑元可以没有变量名，例如``int fun(int,int a){return a/10*10;}``
    - 前缀语义：``int a = ++b; //先完成b+1操作，再赋值``
    - 后缀语义：``int a = b++; //先完成赋值，再b+1操作``

  - 赋值运算符 =, +=
  - 流运算符 (cout) <<, >>
